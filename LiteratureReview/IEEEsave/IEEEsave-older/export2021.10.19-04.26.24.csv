"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"A process model for decision based software development","C. Wild; K. Maly; J. Dong; G. Hu","Dept. of Comput. Sci., Old Dominion Univ., Norfolk, VA, USA; Dept. of Comput. Sci., Old Dominion Univ., Norfolk, VA, USA; Dept. of Comput. Sci., Old Dominion Univ., Norfolk, VA, USA; Dept. of Comput. Sci., Old Dominion Univ., Norfolk, VA, USA","Proceedings. Conference on Software Maintenance 1991","6 Aug 2002","1991","","","42","51","A process model for software maintenance using the decision-based software development (DBSD) paradigm is described. The DBSD paradigm models the process of software development and maintenance as a continuous problem-solving activity where the decision is the focal point. An important aspect of this process is the preparation for perfective and corrective maintenance by identifying conditional decisions whose validation depends on experience with the production system. Validation requires the instrumentation of the production system to collect data which will support or refute the decision. The authors discuss the instrumenting of a prototype DBSD support environment to collect data to validate the proposed process model. Also given are the results of some preliminary data.<<ETX>></ETX>","","0-8186-2325-X","10.1109/ICSM.1991.160305","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=160305","","Programming;Process design;Software maintenance;Software engineering;Problem-solving;Computer science;Productivity;Reliability engineering;Life testing;Software testing","decision support systems;problem solving;programming;software maintenance","process model;software maintenance;decision-based software development;DBSD paradigm;software development;continuous problem-solving activity;corrective maintenance;conditional decisions;prototype DBSD support environment","","1","","20","","6 Aug 2002","","","IEEE","IEEE Conferences"
"Issues in software process automation-from a practical perspective","Cherinka; Overstreet; Cadwell; Ricci","Dept. of Comput. Sci., Old Dominion Univ., Norfolk, VA, USA; Dept. of Comput. Sci., Old Dominion Univ., Norfolk, VA, USA; NA; NA","Proceedings 1994 International Conference on Software Maintenance","6 Aug 2002","1994","","","109","118","This paper describes a process-oriented approach currently employed by a DOD software maintenance organization to use an integrated software engineering environment, largely based on commercially-available tools, for enhancing quality and productivity during software maintenance. Before automated support could be provided to the organization, a complete review of existing procedures was required. The first step was an extensive modeling effort to identify the procedures and document them in detail. It was then possible to identify, and in some cases modify, those procedures that could benefit from automated support. The result of this organization-wide process analysis was then mapped into an existing commercial process enactment tool and used to automate, control, measure, and improve the software maintenance process.<<ETX>></ETX>","","0-8186-6330-8","10.1109/ICSM.1994.336784","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=336784","","Software maintenance;Software development environments;Computer-aided software engineering;Software quality;Software management","software maintenance;project support environments;software tools;software quality","software process automation;process-oriented approach;software maintenance;integrated software engineering environment;commercially-available tools;quality;productivity;organization-wide process analysis;CASE;Theater Software Maintenance Environment;TSME","","","","19","","6 Aug 2002","","","IEEE","IEEE Conferences"
"JAT: A Test Automation Framework for Multi-Agent Systems","R. Coelho; E. Cirilo; U. Kulesza; A. von Staa; A. Rashid; C. Lucena","Computer Science Department, Pontifical Catholic University of Rio de Janeiro - PUC-Rio, Brazil, roberta@inf.puc-rio.br; Computer Science Department, Pontifical Catholic University of Rio de Janeiro - PUC-Rio, Brazil, ecirilo@inf.puc-rio.br; Computer Science Department, Pontifical Catholic University of Rio de Janeiro - PUC-Rio, Brazil, uira@inf.puc-rio.br; Computer Science Department, Pontifical Catholic University of Rio de Janeiro - PUC-Rio, Brazil, arndt@inf.puc-rio.br; Computing Department, Lancaster University, Lancaster, UK, awais@comp.lancs.ac.uk; Computer Science Department, Pontifical Catholic University of Rio de Janeiro - PUC-Rio, Brazil, lucena@inf.puc-rio.br","2007 IEEE International Conference on Software Maintenance","22 Oct 2007","2007","","","425","434","Automated tests have been widely used as a supporting mechanism during software development and maintenance activities. It improves the confidence on software releases as it seeks to uncover regression bugs, and serves as a live documentation which is very useful when evolving systems. Concerning multi agent systems (MASs), some characteristics such as agent autonomy and asynchronous message-based interaction bring a degree of non-determinism which presents new testing challenges. This paper proposes JAT, a framework for building and running MASs test scenarios, which relies on the use of aspect-oriented techniques to monitor the autonomous agents during tests and control the test input of asynchronous test cases. The tool has been developed on top of JADE, a widely used agent platform implemented in Java. We have used JAT on testing 3 different MASs. Our experience shows that JAT can be used to build test scenarios which can achieve high fault-detection effectiveness.","1063-6773","978-1-4244-1255-6","10.1109/ICSM.2007.4362655","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362655","","Automatic testing;System testing;Automation;Multiagent systems;Software testing;Programming;Software maintenance;Computer bugs;Documentation;Monitoring","automatic test software;Java;multi-agent systems;object-oriented programming;program testing;software maintenance","JAT;Jade agent testing;test automation framework;multiagent system;MAS;software development;software maintenance;aspect-oriented techniques;autonomous agent monitoring;Java;high fault-detection effectiveness;JADE","","15","","32","","22 Oct 2007","","","IEEE","IEEE Conferences"
"Re-using software architecture in legacy transformation projects","A. A. Terekhov","St. Petersburg State Univ., Russia","International Conference on Software Maintenance, 2003. ICSM 2003. Proceedings.","7 Oct 2003","2003","","","462","","Summary form only given, as follows. Software engineers sometimes have to take part in the legacy transformation projects, which are characterized by the complete absence of automated migration tools. In such cases, specialists usually aim at reproducing the original system using the new technologies, without adding any new features. It is common knowledge that it makes sense to keep the functionality as close to the original as possible, because in this case on could use the legacy system as an executable set of requirements. We argue that another, less obvious advantage of ""replicating"" the old system is re-use of architectural decisions that built in the original legacy system and usually represent an invaluable treasure, because they reflect an implemented understanding of the application domain.","1063-6773","0-7695-1905-9","10.1109/ICSM.2003.1235456","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235456","","Software architecture;Software tools;Application software;Software maintenance","software architecture;software reusability;project management;software development management","software architecture;software reusability;legacy transformation;software engineering;legacy system","","","","","","7 Oct 2003","","","IEEE","IEEE Conferences"
"Digging deep: Software reengineering supported by database reverse engineering of a system with 30+ years of legacy","S. Strobl; M. Bernhart; T. Grechenig; W. Kleinert","Research Group for Industrial Software, Vienna University of Technology; Research Group for Industrial Software, Vienna University of Technology; Research Group for Industrial Software, Vienna University of Technology; Information Technology Services Vienna University of Technology","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","407","410","This paper describes the industrial experience in performing database reverse engineering on a large scale software reengineering project. The project in question deals with a highly heterogeneous in-house information system (IS) that has grown and evolved in numerous steps over the past three decades. This IS consists of a large number of loosely coupled single purpose systems with a database driven COBOL application at the centre, which has been adopted and enhanced to expose some functionality over the web. The software reengineering effort that provides the context for this paper deals with unifying these components and completely migrating the IS to an up-to-date and homogeneous platform. A database reverse engineering (DRE) process was tailored to suit the project environment consisting of almost 350 tables and 5600 columns. It aims at providing the developers of the software reengineering project with the necessary information about the more than thirty year old legacy databases to successfully perform the data migration. The application of the DRE process resulted in the development of a high-level categorization of the data model, a wiki based redocumentation structure and the essential data-access statistics.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306293","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306293","","Reverse engineering;Software performance;Relational databases;Collaborative software;Computer industry;Large-scale systems;Information systems;Application software;Software reusability;Information technology","COBOL;data models;database management systems;information retrieval;reverse engineering;software maintenance;systems re-engineering","large scale software reengineering;database reverse engineering;heterogeneous in-house information system;single purpose systems;database driven COBOL application;data model;wiki based redocumentation structure;data-access statistics;legacy system","","5","","8","","30 Oct 2009","","","IEEE","IEEE Conferences"
"Reverse Engineering PL/SQL Legacy Code: An Experience Report","M. Habringer; M. Moser; J. Pichler","voestalpine Stahl GmbH, Linz, Austria; Software Analytics & Evolution, Software Competence Center Hagenberg GmbH, Hagenberg, Austria; Software Analytics & Evolution, Software Competence Center Hagenberg GmbH, Hagenberg, Austria","2014 IEEE International Conference on Software Maintenance and Evolution","6 Dec 2014","2014","","","553","556","The reengineering of legacy code is a tedious endeavor. Automatic transformation of legacy code from an old technology to a new one preserves potential problems in legacy code with respect to obsolete, changed, and new business cases. On the other hand, manual analysis of legacy code without assistance of original developers is time consuming and error-prone. For the purpose of reengineering PL/SQL legacy code in the steel making domain, we developed tool support for the reverse engineering of PL/SQL code into a more abstract and comprehensive representation. This representation then serves as input for stakeholders to manually analyze legacy code, to identify obsolete and missing business cases, and, finally, to support the re-implementation of a new system. In this paper we briefly introduce the tool and present results of reverse engineering PL/SQL legacy code in the steel making domain. We show how stakeholders are supported in analyzing legacy code by means of general-purpose analysis techniques combined with domain-specific representations and conclude with some of the lessons learned.","1063-6773","978-1-4799-6146-7","10.1109/ICSME.2014.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976137","reverse engineering;program comprehension;source code analysis","Production;Reverse engineering;Business;Databases;Flow graphs;Software;Steel","reverse engineering;software maintenance;SQL","reverse engineering PL/SQL legacy code;automatic transformation;business cases;legacy code analysis;steel making;general-purpose analysis techniques;domain specific representations","","5","","6","","6 Dec 2014","","","IEEE","IEEE Conferences"
"Automated Refactoring of Legacy Java Software to Enumerated Types","R. Khatchadourian; J. Sawin; A. Rountev","Ohio State University, khatchad@cse.ohio-state.edu; Ohio State University, sawin@cse.ohio-state.edu; Ohio State University, rountev@cse.ohio-state.edu","2007 IEEE International Conference on Software Maintenance","22 Oct 2007","2007","","","224","233","Java 1.5 introduces several new features that offer significant improvements over older Java technology. In this paper we consider the new enum construct, which provides language support for enumerated types. Prior to Java 1.5, programmers needed to employ various patterns (e.g., the weak enum pattern) to compensate for the absence of enumerated types in Java. Unfortunately, these compensation patterns lack several highly-desirable properties of the enum construct, most notably, type safety. We present a novel fully-automated approach for transforming legacy Java code to use the new enumeration construct. This semantics-preserving approach increases type safety, produces code that is easier to comprehend, removes unnecessary complexity, and eliminates brittleness problems due to separate compilation. At the core of the proposed approach is an interprocedural type inferencing algorithm which tracks the flow of enumerated values. The algorithm was implemented as an Eclipse plug-in and evaluated experimentally on 17 large Java benchmarks. Our results indicate that analysis cost is practical and the algorithm can successfully refactor a substantial number of fields to enumerated types. This work is a significant step towards providing automated tool support for migrating legacy Java software to modern Java technologies.","1063-6773","978-1-4244-1255-6","10.1109/ICSM.2007.4362635","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362635","","Java;Inference algorithms;Safety;Algorithm design and analysis;Costs;Programming profession;Software tools;Software maintenance;Robustness;Application software","Java;programming language semantics;software maintenance","legacy Java software;Java technology;enum construct;Java 1.5;legacy Java code;semantics-preserving approach","","7","2","28","","22 Oct 2007","","","IEEE","IEEE Conferences"
"Software modularization operators","G. M. Rama; N. Patel","SETLabs, Infosys, Bangalore, India; SETLabs, Infosys, Pune, India","2010 IEEE International Conference on Software Maintenance","25 Oct 2010","2010","","","1","10","There exists a number of large business critical software systems written in newer languages such as C and Java that are fast becoming legacy and increasingly difficult to maintain. Unlike older monolithic systems, where modularization primarily involves splitting the monolithic code base into modules, for such newer systems which already have some basic modular structure, code decomposition is only one of the many possible activities. Even though the area of software modularization has received considerable attention over these past years, there are hardly any case studies documented in literature on modularizing large C and Java systems. We still do not fully comprehend the activities experienced developers perform when they have to modularize such newer systems. The goal of this paper is to learn from past software modularization projects and identify common recurring patterns. This paper formalizes 6 such patterns, which we term as modularization operators, that are likely to be the basic building blocks of any software modularization activity. The operators presented in this paper are validated using modularization case studies of open source software systems and a proprietary software system and several observations and insights are presented.","1063-6773","978-1-4244-8629-8","10.1109/ICSM.2010.5609546","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609546","","Data structures;Software systems;Software algorithms;Driver circuits;Linux;Maintenance engineering","C language;Java;public domain software;safety-critical software;software maintenance","software modularization operators;large business critical software systems;C language;legacy system;monolithic code;code decomposition;open source software systems;proprietary software system;Java language","","6","","30","","25 Oct 2010","","","IEEE","IEEE Conferences"
"Measuring the progress of projects using the time dependence of code changes","O. Alam; B. Adams; A. E. Hassan","Software Analysis and Intelligence Lab (SAIL), School of Computing, Queen's University, Canada; Software Analysis and Intelligence Lab (SAIL), School of Computing, Queen's University, Canada; Software Analysis and Intelligence Lab (SAIL), School of Computing, Queen's University, Canada","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","329","338","Tracking the progress of a project is often done through imprecise manually gathered information, like progress reports, or through automatic metrics such as Lines Of Code (LOC). Such metrics are too coarse-grained and too imprecise to capture all facets of a project. In this paper, we mine the code changes in the source code repository and study the concept of time dependence of code changes. Using this concept, we can track the progress of a software project as the progress of a building. We can examine how changes build on each other over time and determine the impact of these changes on the quality of a project. In particular, we study whether new changes are built just-in-time or if they build on older, stable code. Through a case study on two large open source projects (PostgreSQL and FreeBSD), we show that time dependence varies across projects and throughout the lifetime of each project. We also show that there is a high linear correlation between building on new code and the occurrence of bugs.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306313","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306313","","Time measurement;Feedback;Project management;Buildings;Software measurement;Information analysis;Lab-on-a-chip;Computer bugs;Software quality;Delay effects","data mining;public domain software;software quality","code change time dependence;code changes mining;source code repository;software project;project quality;open source projects;PostgreSQL;FreeBSD","","7","","34","","30 Oct 2009","","","IEEE","IEEE Conferences"
"Toward documentation of program evolution","T. Vestdam; K. Noermark","Dept. of Comput. Sci., Aalborg Univ., Denmark; Dept. of Comput. Sci., Aalborg Univ., Denmark","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","505","514","The documentation of a program often falls behind the evolution of the program source files. When this happens it may be attractive to shift the documentation mode from updating the documentation to documenting the evolution of the program. This paper describes tools that support the documentation of program evolution. The tools are refinements of the elucidative programming tools, which in turn are inspired from literate programming tools. The version-aware elucidative programming tools are able to process a set of program source files in different versions together with unversioned documentation files. The paper introduces a set of fine grained program evolution steps, which are supported directly by the documentation tools. The automatic discovery of the fine grained program evolution steps makes up a platform for documenting coarse grained and more high-level program evolution steps. It is concluded that our approach can help revitalize older documentation, and that discovery of the fine grained program evolution steps help the programmer in documenting the evolution of the program.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510145","","Documentation;Computer science;Programming profession;Software maintenance","system documentation;software prototyping;software tools;configuration management","program evolution documentation;literate programming tools;version-aware elucidative programming tool","","","","29","","21 Nov 2005","","","IEEE","IEEE Conferences"
"Checking inside the black box: regression testing based on value spectra differences","Tao Xie; D. Notkin","Dept. of Comput. Sci. & Eng., Washington Univ., Seattle, WA, USA; Dept. of Comput. Sci. & Eng., Washington Univ., Seattle, WA, USA","20th IEEE International Conference on Software Maintenance, 2004. Proceedings.","22 Nov 2004","2004","","","28","37","Comparing behaviors of program versions has become an important task in software maintenance and regression testing. Traditional regression testing strongly focuses on black-box comparison of program outputs. Program spectra have recently been proposed to characterize a program's behavior inside the black box. Comparing program spectra of program versions offers insights into the internal behavior differences between versions. We present a new class of program spectra, value spectra, which enriches the existing program spectra family. We compare the value spectra of an old version and a new version to detect internal behavior deviations in the new version. We use a deviation-propagation call tree to present the deviation details. Based on the deviation-propagation call tree, we propose two heuristics to locate deviation roots, which are program locations that trigger the behavior deviations. We have conducted an experiment on seven C programs to evaluate our approach. The results show that our approach can effectively expose program behavior differences between versions even when their program outputs are the same, and our approach reports deviation roots with high accuracy for most programs.","1063-6773","0-7695-2213-0","10.1109/ICSM.2004.1357787","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357787","","Software testing;Computer science;Electronic mail;Software maintenance;Propagation losses;Runtime;Fault diagnosis","program testing;C language;configuration management;software maintenance;regression analysis","black box;regression testing;value spectra differences;program versions;software maintenance;program outputs;program spectra;program behavior;internal behavior differences;internal behavior deviations;deviation-propagation call tree;deviation roots;program locations;C program","","3","1","21","","22 Nov 2004","","","IEEE","IEEE Conferences"
"Automatic test case selection and generation for regression testing of composite service based on extensible BPEL flow graph","B. Li; Dong Qiu; Shunhui Ji; D. Wang","School of Computer Science and Engineering, Southeast University, Nanjing, 210096, China; School of Computer Science and Engineering, Southeast University, Nanjing, 210096, China; School of Computer Science and Engineering, Southeast University, Nanjing, 210096, China; School of Computer Science and Engineering, Southeast University, Nanjing, 210096, China","2010 IEEE International Conference on Software Maintenance","25 Oct 2010","2010","","","1","10","Services are highly reusable, flexible and loosely coupled, which makes the evolution and the maintenance of composite services more complex. Evolution of BPEL composite service covers changes of processes, bindings and interfaces. In this paper, an approach is proposed to select and generate test cases during the evolution of BPEL composite service. The approach identifies the changes by using control-flow analysis technique and comparing the paths in new composite service version and the old one using extensible BPEL flow graph (or XBFG). Message flow is appended to the control flow so that XBFG can describe the behavior of composite service integrally. The binding and predicate constraint information added in XBFG elements can be used in path selection and test case generation. Theory analysis and case study both show that the approach is effective, and test cases coverage rate is high for the changes of processes, bindings and interfaces.","1063-6773","978-1-4244-8629-8","10.1109/ICSM.2010.5609541","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609541","","Tin;Testing;Silicon compounds;Silicon;Flow graphs;Analytical models;Process control","automatic test pattern generation;business data processing;data flow analysis;data flow graphs;program testing;software maintenance;Web services","automatic test case selection;automatic test case generation;regression testing;extensible BPEL flow graph;composite service evolution;composite service maintenance;BPEL composite service;control-flow analysis;message flow;XBFG element;path selection;Web service","","6","","17","","25 Oct 2010","","","IEEE","IEEE Conferences"
"Program analysis and transformation for data-intensive system evolution","A. Cleve","INRIA Lille-Nord Europe, LIFL CNRS UMR 8022, Université de Lille 1s, France","2010 IEEE International Conference on Software Maintenance","25 Oct 2010","2010","","","1","6","Data-intensive software systems are generally made of a database and a collection of application programs in strong interaction with the former. They constitute critical assets in most enterprises, since they support business activities in all production and management domains. Data-intensive systems form most of the so-called legacy systems: they typically are one or more decades old, they are very large, heterogeneous and highly complex. Many of them significantly resist modifications and change due to the lack of documentation, to the use of aging technologies and to inflexible architectures. Therefore, the evolution of data-intensive systems clearly calls for automated support. This thesis explores the use of automated program analysis and transformation techniques in support to the evolution of the database component of the system. The program analysis techniques aim to ease the database evolution process, by helping the developers to understand the data structures that are to be changed, despite the lack of precise and up-to-date documentation. The objective of the program transformation techniques is to support the adaptation of the application programs to the new database. This adaptation process is studied in the context of two realistic database evolution scenarios, namely database database schema refactoring and database platform migration.","1063-6773","978-1-4244-8629-8","10.1109/ICSM.2010.5609724","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609724","","Databases;Reverse engineering;Software systems;Data models;Data structures;Context","data structures;database management systems;program diagnostics;software architecture;software maintenance","data-intensive system evolution;data-intensive software system;application program;legacy system;aging technology;inflexible architectures;automated program analysis;automated program transformation technique;database component evolution;data structures;database schema refactoring;database platform migration","","6","1","29","","25 Oct 2010","","","IEEE","IEEE Conferences"
"An Empirical Study of Multi-entity Changes in Real Bug Fixes","Y. Wang; N. Meng; H. Zhong","Dept. of Comput. Sci., Virginia Tech, Blacksburg, VA, USA; Dept. of Comput. Sci., Virginia Tech, Blacksburg, VA, USA; Dept. of Comput. Sci. & Eng., Shanghai Jiao Tong Univ., Shanghai, China","2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)","11 Nov 2018","2018","","","287","298","Prior studies showed that developers applied repeated bug fixes-similar or identical code changes-to multiple locations. According to the observation, researchers built tools to automatically generate candidate patches from the repeated bug-fixing patterns. However, all such research focuses on the recurring change patterns within single methods. We are curious whether there are also repeated bug fixes that change multiple program entities (e.g., classes, methods, and fields); and if so, how we can leverage such recurring change patterns to further help developers fix bugs. In this paper, we present a comprehensive empirical study on multi-entity bug fixes in terms of their frequency, composition, and semantic meanings. Specifically for each bug fix, we first used our approach InterPart to perform static inter-procedural analysis on partial programs (i.e., the old and new versions of changed Java files), and to extract change dependency graphs (CDGs)-graphs that connect multiple changed entities based on their syntactic dependencies. By extracting common subgraphs from the CDGs of different fixes, we identified the recurring change patterns. Our study on Aries, Cassandra, Derby, and Mahout shows that (1) 52-58% of bug fixes involved multi-entity changes; (2) 6 recurring change patterns commonly exist in all projects; and (3) 19-210 entity pairs were repetitively co-changed mainly because the pairs invoked the same methods, accessed the same fields, or contained similar content. These results helped us better understand the gap between the fixes generated by existing automatic program repair (APR) approaches and the real fixes. Our observations will shed light on the follow-up research of automatic program comprehension and modification.","2576-3148","978-1-5386-7870-1","10.1109/ICSME.2018.00038","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530037","Correlated changes in multiple software entities;change characterization","Computer bugs;Tools;Syntactics;Semantics;Maintenance engineering;Software maintenance;Computer science","graph theory;Java;program debugging;program diagnostics;software maintenance","changed Java files;multiple changed entities;multientity changes;repeated bug-fixing patterns;change multiple program entities;multientity bug fixes;dependency graphs","","9","","78","","11 Nov 2018","","","IEEE","IEEE Conferences"
"Mainframe Migration Based on Screen Scraping","S. Flores-Ruiz; R. Perez-Castillo; C. Domann; S. Puica","Itestra GmbH, München, Germany; Inf. Syst. & Technol. Inst., Univ. of Castilla-La Mancha, Ciudad Real, Spain; Itestra GmbH, München, Germany; Itestra GmbH, München, Germany","2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)","11 Nov 2018","2018","","","675","684","Companies possess a history and large array of legacy information systems that consume a great part of their IT budget in operations and maintenance. These systems are mission-critical, and they cannot be fully discarded since they retain business rules and provide information that is not available anywhere else. Unfortunately, decades-old legacy systems cannot easily withstand modification. Mainframes specifically conglomerate most of these legacy systems. Although there are some white-box solutions for migrating mainframe systems, such solutions lack systematicity and do not provide mechanisms for verifying business rules preservation. Hence, this paper presents a black-box solution (ignoring the internal structure of COBOL programs) which uses a screen scraping technique for migrating mainframe systems toward JavaFX and relational databases. Together with this solution, this paper provides an automatic verification technique to check if the recreated system reflects all the embedded business logic. This proposal has been designed and developed in the context of an industrial project, in which the solution has already migrated 43,000,000 mainframe screens from four systems. The main implication for researchers and practitioners is that screen scraping has proved to be feasible for migrating mainframe systems in large-scale projects within a manageable time-frame while preserving business.","2576-3148","978-1-5386-7870-1","10.1109/ICSME.2018.00077","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530080","Screen Scraping;Mainframe;Legacy Information Systems;COBOL;Migration;Verification","Contracts;Insurance;Maintenance engineering;Companies;Databases","business data processing;COBOL;Java;mainframes;relational databases;software maintenance","mainframe migration;legacy information systems;white-box solutions;business rules preservation;black-box solution;screen scraping technique;IT budget;COBOL program;JavaFX;relational database;automatic verification technique","","","","25","","11 Nov 2018","","","IEEE","IEEE Conferences"
"Reduce, reuse, recycle, recover: Techniques for improved regression testing","M. J. Harrold","College of Computing, Georgia Institute of Technology, Atlanta, GA 30332-0280","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","5","5","One of the most expensive activities that occurs as software is developed and maintained is the testing (or retesting) of the software after it has been modified. Studies suggest that a significant portion of development and maintenance costs go to this retesting, which is known as regression testing. Reports estimate that regression testing consumes as much as 80% of the overall testing budget and can consume up to 50% of the cost of software maintenance. Rapidly changing software and computing environments present many challenges for effective and efficient regression testing in practice. Regression testing can be performed after changes are made to the software, such as after nightly or regular builds, before a new version of the software is released, every time the software is saved and compiled, such as in an agile development environment, or before patches, such as security patches, are released. Regardless of the environment or when it is performed, the goals of regression testing are the same: to improve confidence that the changes behave as intended and that they have not adversely affected unchanged parts of the software. Because regression testing is important, but expensive, much research has been performed, both in industry and in academia, to develop techniques to make regression testing more effective and efficient. This research has also produced many tools and systems that have been used for empirical studies that investigate the effectiveness, scalability, and practicality of the techniques. Researchers have developed techniques for addressing a number of issues related to regression testing, and, in this talk, I will discuss them in four areas. First, techniques attempt to reduce the regression testing time by creating effective regression test suites that test the changed part of the software, by identifying test cases in the regression test suite that do not need to be rerun on the changed software, and by identifying and removing obsolete test cases. Second, techniques can reuse test suites created for one version of the software by identifying those test cases that need to be rerun for testing subsequent versions of the software and by computing an effective ordering for running the test cases. Third, techniques can recycle test cases by monitoring executions to gather test inputs that can be used for retest-ing and by creating unit test cases from system test cases. Finally, techniques could recover test cases by identifying, manipulating, and transforming obsolete test cases, by generating new test cases from old ones, and by repairing test cases when the software changes. In this talk, I will overview the research in testing of evolving software, and discuss achievements to date in managing regression testing by reducing, reusing, recycling, and recovering test cases. I will also present the state of the research and the state of the practice in regression testing. Finally, I will discuss the current trends in both academia and industry, the challenges for solving the difficult problems that exist, the promise for testing of evolving software in the future, and the important open challenges for regression testing in the next decade.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306347","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306347","","Recycling;Software testing;Software performance;System testing;Software maintenance;Performance evaluation;Costs;Security;Scalability;Monitoring","program testing;software maintenance;software reusability","regression testing;software testing;agile development environment;security patches;software evolution;software changes;software reusability;software recycling;software recovery","","5","","","","30 Oct 2009","","","IEEE","IEEE Conferences"
