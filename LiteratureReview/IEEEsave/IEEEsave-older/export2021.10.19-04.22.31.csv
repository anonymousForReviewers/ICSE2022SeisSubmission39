"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"Automated Refactoring of Legacy Java Software to Enumerated Types","R. Khatchadourian; J. Sawin; A. Rountev","Ohio State University, khatchad@cse.ohio-state.edu; Ohio State University, sawin@cse.ohio-state.edu; Ohio State University, rountev@cse.ohio-state.edu","2007 IEEE International Conference on Software Maintenance","22 Oct 2007","2007","","","224","233","Java 1.5 introduces several new features that offer significant improvements over older Java technology. In this paper we consider the new enum construct, which provides language support for enumerated types. Prior to Java 1.5, programmers needed to employ various patterns (e.g., the weak enum pattern) to compensate for the absence of enumerated types in Java. Unfortunately, these compensation patterns lack several highly-desirable properties of the enum construct, most notably, type safety. We present a novel fully-automated approach for transforming legacy Java code to use the new enumeration construct. This semantics-preserving approach increases type safety, produces code that is easier to comprehend, removes unnecessary complexity, and eliminates brittleness problems due to separate compilation. At the core of the proposed approach is an interprocedural type inferencing algorithm which tracks the flow of enumerated values. The algorithm was implemented as an Eclipse plug-in and evaluated experimentally on 17 large Java benchmarks. Our results indicate that analysis cost is practical and the algorithm can successfully refactor a substantial number of fields to enumerated types. This work is a significant step towards providing automated tool support for migrating legacy Java software to modern Java technologies.","1063-6773","978-1-4244-1255-6","10.1109/ICSM.2007.4362635","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362635","","Java;Inference algorithms;Safety;Algorithm design and analysis;Costs;Programming profession;Software tools;Software maintenance;Robustness;Application software","Java;programming language semantics;software maintenance","legacy Java software;Java technology;enum construct;Java 1.5;legacy Java code;semantics-preserving approach","","7","2","28","","22 Oct 2007","","","IEEE","IEEE Conferences"
"Software modularization operators","G. M. Rama; N. Patel","SETLabs, Infosys, Bangalore, India; SETLabs, Infosys, Pune, India","2010 IEEE International Conference on Software Maintenance","25 Oct 2010","2010","","","1","10","There exists a number of large business critical software systems written in newer languages such as C and Java that are fast becoming legacy and increasingly difficult to maintain. Unlike older monolithic systems, where modularization primarily involves splitting the monolithic code base into modules, for such newer systems which already have some basic modular structure, code decomposition is only one of the many possible activities. Even though the area of software modularization has received considerable attention over these past years, there are hardly any case studies documented in literature on modularizing large C and Java systems. We still do not fully comprehend the activities experienced developers perform when they have to modularize such newer systems. The goal of this paper is to learn from past software modularization projects and identify common recurring patterns. This paper formalizes 6 such patterns, which we term as modularization operators, that are likely to be the basic building blocks of any software modularization activity. The operators presented in this paper are validated using modularization case studies of open source software systems and a proprietary software system and several observations and insights are presented.","1063-6773","978-1-4244-8629-8","10.1109/ICSM.2010.5609546","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609546","","Data structures;Software systems;Software algorithms;Driver circuits;Linux;Maintenance engineering","C language;Java;public domain software;safety-critical software;software maintenance","software modularization operators;large business critical software systems;C language;legacy system;monolithic code;code decomposition;open source software systems;proprietary software system;Java language","","6","","30","","25 Oct 2010","","","IEEE","IEEE Conferences"
"Measuring the progress of projects using the time dependence of code changes","O. Alam; B. Adams; A. E. Hassan","Software Analysis and Intelligence Lab (SAIL), School of Computing, Queen's University, Canada; Software Analysis and Intelligence Lab (SAIL), School of Computing, Queen's University, Canada; Software Analysis and Intelligence Lab (SAIL), School of Computing, Queen's University, Canada","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","329","338","Tracking the progress of a project is often done through imprecise manually gathered information, like progress reports, or through automatic metrics such as Lines Of Code (LOC). Such metrics are too coarse-grained and too imprecise to capture all facets of a project. In this paper, we mine the code changes in the source code repository and study the concept of time dependence of code changes. Using this concept, we can track the progress of a software project as the progress of a building. We can examine how changes build on each other over time and determine the impact of these changes on the quality of a project. In particular, we study whether new changes are built just-in-time or if they build on older, stable code. Through a case study on two large open source projects (PostgreSQL and FreeBSD), we show that time dependence varies across projects and throughout the lifetime of each project. We also show that there is a high linear correlation between building on new code and the occurrence of bugs.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306313","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306313","","Time measurement;Feedback;Project management;Buildings;Software measurement;Information analysis;Lab-on-a-chip;Computer bugs;Software quality;Delay effects","data mining;public domain software;software quality","code change time dependence;code changes mining;source code repository;software project;project quality;open source projects;PostgreSQL;FreeBSD","","7","","34","","30 Oct 2009","","","IEEE","IEEE Conferences"
"Toward documentation of program evolution","T. Vestdam; K. Noermark","Dept. of Comput. Sci., Aalborg Univ., Denmark; Dept. of Comput. Sci., Aalborg Univ., Denmark","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","505","514","The documentation of a program often falls behind the evolution of the program source files. When this happens it may be attractive to shift the documentation mode from updating the documentation to documenting the evolution of the program. This paper describes tools that support the documentation of program evolution. The tools are refinements of the elucidative programming tools, which in turn are inspired from literate programming tools. The version-aware elucidative programming tools are able to process a set of program source files in different versions together with unversioned documentation files. The paper introduces a set of fine grained program evolution steps, which are supported directly by the documentation tools. The automatic discovery of the fine grained program evolution steps makes up a platform for documenting coarse grained and more high-level program evolution steps. It is concluded that our approach can help revitalize older documentation, and that discovery of the fine grained program evolution steps help the programmer in documenting the evolution of the program.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510145","","Documentation;Computer science;Programming profession;Software maintenance","system documentation;software prototyping;software tools;configuration management","program evolution documentation;literate programming tools;version-aware elucidative programming tool","","","","29","","21 Nov 2005","","","IEEE","IEEE Conferences"
