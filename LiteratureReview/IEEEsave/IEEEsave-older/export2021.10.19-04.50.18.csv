"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"Self-Organizing Roles on Agile Software Development Teams","R. Hoda; J. Noble; S. Marshall","The University of Auckland, Auckland; Victoria University of Wellington, Wellington; Victoria University of Wellington, Wellington","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","422","444","Self-organizing teams have been recognized and studied in various forms-as autonomous groups in socio-technical systems, enablers of organizational theories, agents of knowledge management, and as examples of complex-adaptive systems. Over the last decade, self-organizing teams have taken center stage in software engineering when they were incorporated as a hallmark of Agile methods. Despite the long and rich history of self-organizing teams and their recent popularity with Agile methods, there has been little research on the topic within software wngineering. Particularly, there is a dearth of research on how Agile teams organize themselves in practice. Through a Grounded Theory research involving 58 Agile practitioners from 23 software organizations in New Zealand and India over a period of four years, we identified informal, implicit, transient, and spontaneous roles that make Agile teams self-organizing. These roles-Mentor, Coordinator, Translator, Champion, Promoter, and Terminator-are focused toward providing initial guidance and encouraging continued adherence to Agile methods, effectively managing customer expectations and coordinating customer collaboration, securing and sustaining senior management support, and identifying and removing team members threatening the self-organizing ability of the team. Understanding these roles will help software development teams and their managers better comprehend and execute their roles and responsibilities as a self-organizing team.","1939-3520","","10.1109/TSE.2012.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6197202","Self-organizing;team roles;software engineering;Agile software development;grounded theory","Programming;Organizations;Collaboration;Software;Organizing;Software engineering","knowledge management;software management;software prototyping;team working","self-organizing roles;agile software development teams;self-organizing teams;autonomous groups;socio-technical systems;organizational theories enablers;knowledge management agents;complex-adaptive system examples;software engineering;grounded theory research;New Zealand;India;mentor role;coordinator role;translator role;champion role;promoter role;terminator role;customer expectation management;customer collaboration coordination;senior management support security;senior management support sustainability","","102","","115","","8 May 2012","","","IEEE","IEEE Journals"
"Two-dimensional specification of universal quantification in a graphical database query language","K. -. Whang; A. Malhotra; G. H. Sockut; L. Burns; K. -. Choi","Dept. of Comput. Sci., Korea Adv. Inst. of Sci. & Technol., Daejeon, South Korea; NA; NA; NA; NA","IEEE Transactions on Software Engineering","6 Aug 2002","1992","18","3","216","224","A technique is proposed for specifying universal quantification and existential quantification (combined with negation) in a two-dimensional (graphical) database query language. Unlike other approaches that provide set operators to simulate universal quantification, this technique allows a direct representation of universal quantification. Syntactic constructs for specifying universal and existential quantifications, two-dimensional translation of universal quantification to existential quantification (with negation), and translation of existentially quantified two-dimensional queries to relational queries are presented. The resulting relational queries can be processed directly by many existing database systems. The authors claim that this technique renders universal quantifications easy to understand. To substantiate this claim, they provide a simple, easy-to-follow guideline for constructing universally quantified queries.<<ETX>></ETX>","1939-3520","","10.1109/32.126770","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=126770","","Database languages;Relational databases;Calculus;Database systems;Programming profession;Senior members;Guidelines;Computer science;Data models","computer graphics;database theory;formal specification;query languages;relational databases","graphical database query language;universal quantification;existential quantification;direct representation;two-dimensional translation;existentially quantified two-dimensional queries;relational queries","","17","4","17","","6 Aug 2002","","","IEEE","IEEE Journals"
"Processing Implication on Queries","Xian-he Sun; N. N. Kamel; L. M. Ni",Departmcnt of Computer Science. Michigan State University. East Lansing. Ml; NA; NA,"IEEE Transactions on Software Engineering","6 Aug 2002","1989","15","10","1168","1175","","1939-3520","","10.1109/TSE.1989.559764","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=559764","","Database systems;Relational databases;Sun;Distributed databases;Costs;Polynomials;Senior members;Protocols;Query processing","","Database;Derivability Problem;Directed Graph;Implication Problem;Mathematical Logic;NP-hard;project-select-joint queries;satisfiability","","11","","18","","6 Aug 2002","","","IEEE","IEEE Journals"
"Design and specification of iterators using the swapping paradigm","B. W. Weide; S. H. Edwards; D. E. Harms; D. A. Lamb","Dept. of Comput. & Inf. Sci., Ohio State Univ., Columbus, OH, USA; Dept. of Comput. & Inf. Sci., Ohio State Univ., Columbus, OH, USA; NA; NA","IEEE Transactions on Software Engineering","6 Aug 2002","1994","20","8","631","643","How should iterators be abstracted and encapsulated in modern imperative languages? We consider the combined impact of several factors on this question: the need for a common interface model for user defined iterator abstractions, the importance of formal methods in specifying such a model, and problems involved in modular correctness proofs of iterator implementations and clients. A series of iterator designs illustrates the advantages of the swapping paradigm over the traditional copying paradigm. Specifically, swapping based designs admit more efficient implementations while offering relatively straightforward formal specifications and the potential for modular reasoning about program behavior. The final proposed design schema is a common interface model for an iterator for any generic collection.<<ETX>></ETX>","1939-3520","","10.1109/32.310672","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=310672","","Formal specifications;Reasoning about programs;Information science;Senior members;Forward contracts;Modems;Packaging;Proposals;Computerized monitoring;Military computing","formal specification;program verification;data encapsulation","iterators;swapping paradigm;imperative languages;common interface model;user defined iterator abstractions;formal methods;modular correctness proofs;iterator designs;formal specification;modular reasoning;program verification;proof of correctness;swapping","","4","","20","","6 Aug 2002","","","IEEE","IEEE Journals"
"Performance analysis of Time Warp with multiple homogeneous processors","A. Gupta; I. F. Akyildiz; R. M. Fujimoto","Coll. of Comput., Georgia Inst. of Technol., Atlanta, GA, USA; Coll. of Comput., Georgia Inst. of Technol., Atlanta, GA, USA; Coll. of Comput., Georgia Inst. of Technol., Atlanta, GA, USA","IEEE Transactions on Software Engineering","6 Aug 2002","1991","17","10","1013","1027","The behavior of n interacting processors synchronized by the Time Warp protocol is analyzed using a discrete-state, continuous-time Markov chain model. The performance and dynamics of the processes (or processors) are analyzed under the following assumptions: exponential task times and timestamp increments on messages, each event message generates one new message that is sent to a randomly selected process, negligible rollback, state saving, and communication delay, unbounded message buffers, and homogeneous processors. Several performance measures are determined, such as: the fraction of processed events that commit, speedup, rollback probability, expected length of rollback, the probability mass function for the number of uncommitted processed events, the probability distribution function for the virtual time of a process, and the fraction of time the processors remain idle. The analysis is approximate, thus the results have been validated through performance measurements of a Time Warp testbed executing on a shared-memory multiprocessor.<<ETX>></ETX>","1939-3520","","10.1109/32.99190","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=99190","","Performance analysis;Discrete event simulation;Time measurement;Time warp simulation;Synchronization;Senior members;Protocols;Delay;Length measurement;Velocity measurement","discrete event simulation;Markov processes;multiprocessing systems;performance evaluation;protocols","parallel simulation;interacting processors;Time Warp protocol;discrete-state;continuous-time Markov chain model;exponential task times;timestamp increments;event message;negligible rollback;state saving;communication delay;unbounded message buffers;homogeneous processors;performance measures;processed events;speedup;rollback probability;probability mass function;uncommitted processed events;probability distribution function;virtual time;Time Warp testbed;shared-memory multiprocessor","","29","","22","","6 Aug 2002","","","IEEE","IEEE Journals"
"Generalized stochastic Petri nets: a definition at the net level and its implications","G. Chiola; M. A. Marsan; G. Balbo; G. Conte","Dipartimento di Inf., Torino Univ., Italy; NA; NA; NA","IEEE Transactions on Software Engineering","6 Aug 2002","1993","19","2","89","107","The class of Petri nets obtained by eliminating timing from generalized stochastic Petri net (GSPN) models while preserving the qualitative behavior is identified. Structural results for those nets are derived, obtaining the first structural analysis of Petri nets with priority and inhibitor arcs. A revision of the GSPN definition based on the structural properties of the models is presented. It is shown that for a (wide) class of nets, the definition of firing probabilities of conflicting immediate transitions does not require the information on reachable markings. Identification of the class of models for which the net-level specification is possible is also based on the structural analysis results. The procedure for the model specification is illustrated by means of an example. It is also shown that a net-level specification of the model associated with efficient structural analysis techniques can have a substantial impact on model analysis.<<ETX>></ETX>","1939-3520","","10.1109/32.214828","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=214828","","Stochastic processes;Petri nets;Power system modeling;Computational modeling;Concurrent computing;Performance analysis;Switches;Distributed computing;Senior members;Proposals","formal specification;performance evaluation;Petri nets;stochastic processes","generalized stochastic Petri net;qualitative behavior;structural analysis;structural properties;firing probabilities;net-level specification;model specification","","150","","46","","6 Aug 2002","","","IEEE","IEEE Journals"
"In-process evaluation for software inspection and test","J. K. Chaar; M. J. Halliday; I. S. Bhandari; R. Chillarege","IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA","IEEE Transactions on Software Engineering","6 Aug 2002","1993","19","11","1055","1070","The goal of software inspection and test is to reduce the expected cost of software failure over the life of a product. The authors extend the use of defect triggers, the events that cause defects to be discovered, to help evaluate the effectiveness of inspections and test scenarios. In the case of inspections, the defect trigger is defined as a set of values that associate the skills of the inspector with the discovered defect. Similarly, for test scenarios, the defect trigger values embody the deferring strategies being used in creating these scenarios. The usefulness of triggers in evaluating the effectiveness of software inspections and tests is demonstrated by evaluating the inspection and test activities of some software products. These evaluations are used to point to deficiencies in inspection and test strategies, and to progress made in improving such strategies. The trigger distribution of the entire inspection or test series may then be used to highlight areas for further investigation, with the aim of improving the design, implementation, and test processes.<<ETX>></ETX>","1939-3520","","10.1109/32.256853","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=256853","","Inspection;Software testing;Software quality;Life testing;Costs;Programming;Senior members;Software reliability;Software development management;Software maintenance","program testing;software quality;software reliability","in-process evaluation;software inspection;software testing;expected cost;software failure;defect triggers;test scenarios","","37","1","37","","6 Aug 2002","","","IEEE","IEEE Journals"
"A pre-run-time scheduling algorithm for hard real-time systems","T. Shepard; J. A. M. Gagne","Dept. of Electr. & Comput. Eng., R. Mil. Coll. of Canada, Kingston, Ont., Canada; NA","IEEE Transactions on Software Engineering","6 Aug 2002","1991","17","7","669","677","Process scheduling, an important issue in the design and maintenance of hard real-time systems, is discussed. A pre-run-time scheduling algorithm that addresses the problem of process sequencing is presented. The algorithm is designed for multiprocessor applications with preemptable processes having release times, computation times, deadlines and arbitrary precedence and exclusion constraints. The algorithm uses a branch-and-bound implicit enumeration technique to generate a feasible schedule for each processor. The set of feasible schedules ensures that the timing specifications of the processes are observed and that all the precedence and exclusion constraints between pairs of processes are satisfied. the algorithm was tested using a model derived from the F-18 mission computer operational flight program.<<ETX>></ETX>","1939-3520","","10.1109/32.83903","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=83903","","Scheduling algorithm;Real time systems;Processor scheduling;Timing;Application software;Runtime;Software algorithms;Software maintenance;Senior members;Algorithm design and analysis","aerospace computing;multiprocessing systems;real-time systems;scheduling","hard real-time systems;pre-run-time scheduling algorithm;process sequencing;multiprocessor applications;preemptable processes;release times;computation times;deadlines;arbitrary precedence;exclusion constraints;branch-and-bound implicit enumeration technique;feasible schedule;timing specifications;F-18 mission computer operational flight program","","25","6","9","","6 Aug 2002","","","IEEE","IEEE Journals"
"Prediction of software reliability using connectionist models","N. Karunanithi; D. Whitley; Y. K. Malaiya","Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA","IEEE Transactions on Software Engineering","6 Aug 2002","1992","18","7","563","574","The usefulness of connectionist models for software reliability growth prediction is illustrated. The applicability of the connectionist approach is explored using various network models, training regimes, and data representation methods. An empirical comparison is made between this approach and five well-known software reliability growth models using actual data sets from several different software projects. The results presented suggest that connectionist models may adapt well across different data sets and exhibit a better predictive accuracy. The analysis shows that the connectionist approach is capable of developing models of varying complexity.<<ETX>></ETX>","1939-3520","","10.1109/32.148475","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=148475","","Software reliability;Predictive models;Parametric statistics;Educational institutions;Artificial neural networks;Senior members;Analytical models;Testing;Accuracy;Application software","neural nets;software reliability","software reliability;connectionist models;network models;training regimes;data representation methods;complexity","","147","","37","","6 Aug 2002","","","IEEE","IEEE Journals"
"Test selection based on communicating nondeterministic finite-state machines using a generalized Wp-method","Gang Luo; G. von Bochmann; A. Petrenko","Dept. d'Inf. et de Recherche Oper., Montreal Univ., Que., Canada; Dept. d'Inf. et de Recherche Oper., Montreal Univ., Que., Canada; Dept. d'Inf. et de Recherche Oper., Montreal Univ., Que., Canada","IEEE Transactions on Software Engineering","6 Aug 2002","1994","20","2","149","162","Presents a method of generating test sequences for concurrent programs and communication protocols that are modeled as communicating nondeterministic finite-state machines (CNFSMs). A conformance relation, called trace-equivalence, is defined within this model, serving as a guide to test generation. A test generation method for a single nondeterministic finite-state machine (NFSM) is developed, which is an improved and generalized version of the Wp-method that generates test sequences only for deterministic finite-state machines. It is applicable to both nondeterministic and deterministic finite-state machines. When applied to deterministic finite-state machines, it yields usually smaller test suites with full fault coverage than the existing methods that also provide full fault coverage, provided that the number of states in implementation NFSMs are bounded by a known integer. For a system of CNFSMs, the test sequences are generated in the following manner: a system of CNFSMs is first reduced into a single NFSM by reachability analysis; then the test sequences are generated from the resulting NFSM using the generalized Wp-method.<<ETX>></ETX>","1939-3520","","10.1109/32.265636","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=265636","","Protocols;Software testing;System testing;Concurrent computing;Communication system software;Computer science;Senior members;Reachability analysis;Software engineering","program testing;multiprocessing programs;protocols;finite state machines;conformance testing;specification languages;software engineering;programming theory","test selection;communicating nondeterministic finite-state machines;generalized Wp-method;test sequence generation;concurrent programs;communication protocols;conformance relation;trace-equivalence;deterministic finite-state machines;test suites;fault coverage;reachability analysis;protocol conformance testing;protocol engineering;SDL;software engineering;software testing","","149","","42","","6 Aug 2002","","","IEEE","IEEE Journals"
"Extending objects to support multiple interfaces and access control","B. Hailpern; H. Ossher","IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA","IEEE Transactions on Software Engineering","6 Aug 2002","1990","16","11","1247","1257","A mechanism, called views, that allows programmers to specify multiple interfaces for objects and to control explicitly access to each interface is described. This mechanism provides a simple and flexible means of specifying enforceable access restrictions at many levels of granularity. It also results in system organization that supports browsing based on a number of different criteria. Views is defined, some examples of its uses are given, the impact of views on system organization is discussed, and five approaches to implementing views are outlined.<<ETX>></ETX>","1939-3520","","10.1109/32.60313","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=60313","","Access control;Encapsulation;Senior members;Control systems;Protection;Data structures","data structures;object-oriented programming","multiple interfaces;access control;views;objects;enforceable access restrictions;granularity;system organization;browsing","","29","13","30","","6 Aug 2002","","","IEEE","IEEE Journals"
"Semantics-based inference algorithms for adaptive visual environments","F. Ferrucci; G. Tortora; M. Tucci; G. Vitiello","Dipartimento di Inf. ed Applicazioni, Salerno Univ., Italy; Dipartimento di Inf. ed Applicazioni, Salerno Univ., Italy; Dipartimento di Inf. ed Applicazioni, Salerno Univ., Italy; Dipartimento di Inf. ed Applicazioni, Salerno Univ., Italy","IEEE Transactions on Software Engineering","6 Aug 2002","1996","22","10","730","750","The paper presents a grammatical inference methodology for the generation of visual languages, that benefits from the availability of semantic information about the sample sentences. Several well-known syntactic inference algorithms are shown to obey a general inference scheme, which the authors call the Gen-Inf scheme. Then, all the algorithms of the Gen-Inf scheme are modified in agreement with the introduced semantics-based inference methodology. The use of grammatical inference techniques in the design of adaptive user interfaces was previously experimented with the VLG system for visual language generation. The system is a powerful tool for specifying, designing, and interpreting customized visual languages for different applications. They enhance the adaptivity of the VLG system to any visual environment by exploiting the proposed semantics-based inference methodology. As a matter of fact, a more general model of visual language generation is achieved, based on the Gen-Inf scheme, where the end-user is allowed to choose the algorithm which best fits his/her requirements within the particular application environment.","1939-3520","","10.1109/32.544351","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=544351","","Inference algorithms;User interfaces;Chromium;Senior members;Power system modeling;Pattern recognition;Artificial intelligence;Computer languages;Process design;Image processing","visual languages;grammars;computational linguistics;adaptive systems;graphical user interfaces;user interface management systems","semantics-based inference algorithms;adaptive visual environments;grammatical inference methodology;visual language generation;semantic information;sample sentences;syntactic inference algorithms;Gen-Inf scheme;adaptive user interface design;customized visual language specification;customized visual language interpretation;customized visual language design","","3","","22","","6 Aug 2002","","","IEEE","IEEE Journals"
"A formal framework for on-line software version change","D. Gupta; P. Jalote; G. Barua","Dept. of Comput. Sci. & Eng., Indian Inst. of Technol., Kanpur, India; Dept. of Comput. Sci. & Eng., Indian Inst. of Technol., Kanpur, India; NA","IEEE Transactions on Software Engineering","6 Aug 2002","1996","22","2","120","131","The usual way of installing a new version of a software system is to shut down the running program and then install the new version. This necessitates a sometimes unacceptable delay during which service is denied to the users of the software. An online software replacement system replaces parts of the software while it is in execution, thus eliminating the shutdown. While a number of implementations of online version change systems have been described in the literature, little investigation has been done on its theoretical aspects. We describe a formal framework for studying online software version change. We give a general definition of validity of an online change, show that it is in general undecidable and then develop sufficient conditions for ensuring validity for a procedural language.","1939-3520","","10.1109/32.485222","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=485222","","Software systems;Delay;Senior members;Sufficient conditions;Data analysis;Software development management;Computer science;Electronic switching systems","configuration management;computer installation;utility programs;formal specification;decidability","formal framework;online software version change;on-line software version change;software system;online software replacement system;online version change systems;validity;undecidable;sufficient conditions;procedural language","","113","7","17","","6 Aug 2002","","","IEEE","IEEE Journals"
"Coordination Challenges in Large-Scale Software Development: A Case Study of Planning Misalignment in Hybrid Settings","S. Bick; K. Spohrer; R. Hoda; A. Scheerer; A. Heinzl","SAP SE, Walldorf, Germany; University of Mannheim, Mannheim, Germany; University of Auckland, Auckland, New Zealand; SAP SE, Walldorf, Germany; University of Mannheim, Mannheim, Germany","IEEE Transactions on Software Engineering","14 Oct 2018","2018","44","10","932","950","Achieving effective inter-team coordination is one of the most pressing challenges in large-scale software development. Hybrid approaches of traditional and agile development promise combining the overview and predictability of long-term planning on an inter-team level with the flexibility and adaptability of agile development on a team level. It is currently unclear, however, why such hybrids often fail. Our case study within a large software development unit of 13 teams at a global enterprise software company explores how and why a combination of traditional planning on an inter-team level and agile development on a team level can result in ineffective coordination. Based on a variety of data, including interviews with scrum masters, product owners, architects and senior management, and using Grounded Theory data analysis procedures, we identify a lack of dependency awareness across development teams as a key explanation of ineffective coordination. Our findings show how a lack of dependency awareness emerges from misaligned planning activities of specification, prioritization, estimation and allocation between agile team and traditional inter-team levels and ultimately prevents effective coordination. Knowing about these issues, large-scale hybrid projects in similar contexts can try to better align their planning activities across levels to improve dependency awareness and in turn achieve more effective coordination.","1939-3520","","10.1109/TSE.2017.2730870","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7990187","Large-scale software development;agile;hybrid;inter-team coordination;dependency awareness;planning alignment;information systems development","Software;Planning;Agile software development;Companies;Task analysis;Interviews","data analysis;project management;software development management;software prototyping;team working","large-scale software development;agile development;long-term planning;inter-team level;software development unit;global enterprise software company;ineffective coordination;agile team;large-scale hybrid projects;coordination challenges;planning misalignment;hybrid settings;effective inter-team coordination;pressing challenges;scrum masters;product owners;architects;senior management;grounded theory data analysis procedures","","6","","97","IEEE","24 Jul 2017","","","IEEE","IEEE Journals"
"Communication metrics for software development","A. H. Dutoit; B. Bruegge","Inst. fur Inf., Tech. Univ. Munchen, Germany; NA","IEEE Transactions on Software Engineering","6 Aug 2002","1998","24","8","615","628","Presents empirical evidence that metrics on communication artifacts generated by groupware tools can be used to gain significant insight into the development process that produced them. We describe a test-bed for developing and testing communication metrics, a senior-level software engineering project course at Carnegie Mellon University, in which we conducted several studies and experiments from 1991-1996 with more than 400 participants. Such a test-bed is an ideal environment for empirical software engineering, providing sufficient realism while allowing for controlled observation of important project parameters. We describe three proof-of-concept experiments to illustrate the value of communication metrics in software development projects. Finally, we propose a statistical framework based on structural equations for validating these communication metrics.","1939-3520","","10.1109/32.707697","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=707697","","Programming;Software testing;Software engineering;Equations;Collaborative software;Collaborative work;Communication system control;Software tools;Context;Computer Society","software metrics;groupware;statistics;equations;educational courses;computer science education","communication metrics;software development;communication artifacts;groupware tools;senior-level software engineering project course;Carnegie Mellon University;empirical software engineering;project parameter controlled observation;statistical framework;structural equations;validation","","24","","31","","6 Aug 2002","","","IEEE","IEEE Journals"
"Comparing the Defect Reduction Benefits of Code Inspection and Test-Driven Development","J. W. Wilkerson; J. F. Nunamaker; R. Mercer","Pennsylvania State University, Erie, Erie; University of Arizona, Tucson; University of Arizona, Tucson","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","547","560","This study is a quasi experiment comparing the software defect rates and implementation costs of two methods of software defect reduction: code inspection and test-driven development. We divided participants, consisting of junior and senior computer science students at a large Southwestern university, into four groups using a two-by-two, between-subjects, factorial design and asked them to complete the same programming assignment using either test-driven development, code inspection, both, or neither. We compared resulting defect counts and implementation costs across groups. We found that code inspection is more effective than test-driven development at reducing defects, but that code inspection is also more expensive. We also found that test-driven development was no more effective at reducing defects than traditional programming methods.","1939-3520","","10.1109/TSE.2011.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5750007","Agile programming;code inspections and walk throughs;reliability;test-driven development;testing strategies;empirical study.","Inspection;Software;Testing;Java;Writing;Programming profession","program testing;system recovery","defect reduction benefits;code inspection;test driven development;quasi experiment;software defect rates;software defect reduction;senior computer science students;junior computer science students;programming assignment","","18","","47","","15 Apr 2011","","","IEEE","IEEE Journals"
"Evaluating the effect of a delegated versus centralized control style on the maintainability of object-oriented software","E. Arisholm; D. I. K. Sjoberg","Dept. of Software Eng., Simula Res. Lab., Lysaker, Norway; Dept. of Software Eng., Simula Res. Lab., Lysaker, Norway","IEEE Transactions on Software Engineering","26 Jul 2004","2004","30","8","521","534","A fundamental question in object-oriented design is how to design maintainable software. According to expert opinion, a delegated control style, typically a result of responsibility-driven design, represents object-oriented design at its best, whereas a centralized control style is reminiscent of a procedural solution, or a ""bad"" object-oriented design. We present a controlled experiment that investigates these claims empirically. A total of 99 junior, intermediate, and senior professional consultants from several international consultancy companies were hired for one day to participate in the experiment. To compare differences between (categories of) professionals and students, 59 students also participated. The subjects used professional Java tools to perform several change tasks on two alternative Java designs that had a centralized and delegated control style, respectively. The results show that the most skilled developers, in particular, the senior consultants, require less time to maintain software with a delegated control style than with a centralized control style. However, more novice developers, in particular, the undergraduate students and junior consultants, have serious problems understanding a delegated control style, and perform far better with a centralized control style. Thus, the maintainability of object-oriented software depends, to a large extent, on the skill of the developers who are going to maintain it. These results may have serious implications for object-oriented development in an industrial context: having senior consultants design object-oriented systems may eventually pose difficulties unless they make an effort to keep the designs simple, as the cognitive complexity of ""expert"" designs might be unmanageable for less skilled maintainers.","1939-3520","","10.1109/TSE.2004.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1316869","Index Terms- Design principles;responsibility delegation;control styles;object-oriented design;object-oriented programming;software maintainability;controlled experiment.","Software maintenance;Centralized control;Software design;Java;Design methodology;Unified modeling language;Business communication;Logic;Electrical equipment industry;Object oriented programming","software maintenance;object-oriented programming;Java;software development management","object-oriented software maintainability;object-oriented design;professional Java tool;Java design;centralized control style;delegated control style;object-oriented development;object-oriented programming","","88","","33","","26 Jul 2004","","","IEEE","IEEE Journals"
"Evaluating Pair Programming with Respect to System Complexity and Programmer Expertise","E. Arisholm; H. Gallis; T. Dyba; D. I. K. Sjoberg","Simula Research Laboratory, PO Box 134, NO-1325 Lysaker, Norway; Simula Research Laboratory, PO Box 134, NO-1325 Lysaker, Norway; Simula Research Laboratory and SINTEF Information and Communication Technology, NO-7465 Trondheim, Norway; Simula Research Laboratory, PO Box 134, NO-1325 Lysaker, Norway","IEEE Transactions on Software Engineering","8 Jan 2007","2007","33","2","65","86","A total of 295 junior, intermediate, and senior professional Java consultants (99 individuals and 98 pairs) from 29 international consultancy companies in Norway, Sweden, and the UK were hired for one day to participate in a controlled experiment on pair programming. The subjects used professional Java tools to perform several change tasks on two alternative Java systems with different degrees of complexity. The results of this experiment do not support the hypotheses that pair programming in general reduces the time required to solve the tasks correctly or increases the proportion of correct solutions. On the other hand, there is a significant 84 percent increase in effort to perform the tasks correctly. However, on the more complex system, the pair programmers had a 48 percent increase in the proportion of correct solutions but no significant differences in the time taken to solve the tasks correctly. For the simpler system, there was a 20 percent decrease in time taken but no significant differences in correctness. However, the moderating effect of system complexity depends on the programmer expertise of the subjects. The observed benefits of pair programming in terms of correctness on the complex system apply mainly to juniors, whereas the reductions in duration to perform the tasks correctly on the simple system apply mainly to intermediates and seniors. It is possible that the benefits of pair programming will exceed the results obtained in this experiment for larger, more complex tasks and if the pair programmers have a chance to work together over a longer period of time","1939-3520","","10.1109/TSE.2007.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4052584","Empirical software engineering;pair programming;extreme programming;design principles;control styles;object-oriented programming;software maintainability;quasi-experiment.","Programming profession;Time measurement;Java;Software engineering;Software maintenance;Keyboards;Cost function;Power measurement;Computer industry","Java;object-oriented programming;task analysis;team working","pair programming;system complexity;programmer expertise;Java","","142","","50","","8 Jan 2007","","","IEEE","IEEE Journals"
"Guest Editorial Software Management: We Must Find a Way","R. E. Merwin",Special Section on Software Management,"IEEE Transactions on Software Engineering","18 Sep 2006","1978","SE-4","4","307","308","SOFTWARE management is a term which inspires many different reactions from the broad range of practitioners in the field of data processing. The term has many dimensions ranging from the first and second line manager of a software development activity who plies his trade with little to fall back on other than his prior experience, and native skills and intuition. Contrast this with a senior executive who, because of lack of understanding of software management, is frustrated in trying to determine if his company can produce a software program on schedule and within budget. The data processing landscape is littered with examples of major software developments which faltered and then expired. That this situation should exist, after almost a quarter-century of experience with implementing these systems, is one of the enigmas of the rapidly expanding data processing industry.","1939-3520","","10.1109/TSE.1978.231516","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702539","","Data processing;Software development management;Programming;Engineering management;US Department of Defense;Job shop scheduling;Seminars;Resource management;Project management;Financial management","","","","2","","14","","18 Sep 2006","","","IEEE","IEEE Journals"
"Measuring Program Comprehension: A Large-Scale Field Study with Professionals","X. Xia; L. Bao; D. Lo; Z. Xing; A. E. Hassan; S. Li","Zhejiang University, Hangzhou, China; Zhejiang University, Hangzhou, China; Singapore Management University, Singapore; Australian National University, Canberra, ACT, Australia; Queen’s University, Kingston, ON, Canada; Zhejiang University, Hangzhou, China","IEEE Transactions on Software Engineering","14 Oct 2018","2018","44","10","951","976","During software development and maintenance, developers spend a considerable amount of time on program comprehension activities. Previous studies show that program comprehension takes up as much as half of a developer's time. However, most of these studies are performed in a controlled setting, or with a small number of participants, and investigate the program comprehension activities only within the IDEs. However, developers' program comprehension activities go well beyond their IDE interactions. In this paper, we extend our ActivitySpace framework to collect and analyze Human-Computer Interaction (HCI) data across many applications (not just the IDEs). We follow Minelli et al.'s approach to assign developers' activities into four categories: navigation, editing, comprehension, and other. We then measure the comprehension time by calculating the time that developers spend on program comprehension, e.g., inspecting console and breakpoints in IDE, or reading and understanding tutorials in web browsers. Using this approach, we can perform a more realistic investigation of program comprehension activities, through a field study of program comprehension in practice across a total of seven real projects, on 78 professional developers, and amounting to 3,148 working hours. Our study leverages interaction data that is collected across many applications by the developers. Our study finds that on average developers spend ~58 percent of their time on program comprehension activities, and that they frequently use web browsers and document editors to perform program comprehension activities. We also investigate the impact of programming language, developers' experience, and project phase on the time that is spent on program comprehension, and we find senior developers spend significantly less percentages of time on program comprehension than junior developers. Our study also highlights the importance of several research directions needed to reduce program comprehension time, e.g., building automatic detection and improvement of low quality code and documentation, construction of software-engineering-specific search engines, designing better IDEs that help developers navigate code and browse information more efficiently, etc.","1939-3520","","10.1109/TSE.2017.2734091","National Natural Science Foundation of China(grant numbers:61602403,61572426); National Key Technology R&D Program; Ministry of Science and Technology of China(grant numbers:2015BAH17F01); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7997917","Program comprehension;field study;inference model","Navigation;Software;Time measurement;Browsers;Maintenance engineering;Programming;Debugging","human computer interaction;Internet;program compilers;reverse engineering;search engines;software maintenance","program comprehension activities;program comprehension time;developers time;software development;software maintenance;IDE interactions;ActivitySpace framework;human computer interaction;Web browsers;programming language;project phase;software-engineering;search engines","","20","","63","IEEE","31 Jul 2017","","","IEEE","IEEE Journals"
"Investigating the Impact of Development Task on External Quality in Test-Driven Development: An Industry Experiment","A. Tosun; O. Dieste; S. Vegas; D. Pfahl; K. Rungi; N. Juristo","Computer Engineering, Istanbul Technical University, Istanbul, Istanbul Turkey 34469 (e-mail: tosunay@itu.edu.tr); Lenguajes y Sistemas Informaticos e Ingenieria de Software, Universidad Politecnica de Madrid, Boadilla del Monte, Madrid Spain 28660 (e-mail: odieste@fi.upm.es); Languajes, computer systems and software engineering, Universidad Politecnica de Madrid, Boadilla del Monte, Madrid Spain 28660 (e-mail: svegas@fi.upm.es); Institute of Computer Science, University of Tartu, Tartu, Tartu Estonia (e-mail: dietmar.pfahl@ut.ee); IT, Testlio, Oulu, Oulu Finland (e-mail: kerli.rungi@gmail.com); Escuela Técnica Superior de Ingenieros Informáticos, Universidad Politecnica de Madrid, Boadilla del Monte, Madrid Spain 28660 (e-mail: natalia@fi.upm.es)","IEEE Transactions on Software Engineering","","2019","PP","99","1","1","Reviews on test-driven development (TDD) studies suggest that the conflicting results reported in the literature are due to unobserved factors, such as the tasks used in the experiments, and highlight that there are very few industry experiments conducted with professionals. The goal of this study is to investigate the impact of a new factor, the chosen task, and the development approach on external quality in an industrial experiment setting with 17 professionals. The participants are junior to senior developers in programming with Java, beginner to novice in unit testing, JUnit, and they have no prior experience in TDD. The experimental design is a <formula><tex>$2 \times 2$</tex></formula> cross-over, i.e., we use two tasks for each of the two approaches, namely TDD and incremental test-last development (ITLD). Our results reveal that both development approach and task are significant factors with regards to the external quality achieved by the participants. More specifically, the participants produce higher quality code during ITLD in which splitting user stories into subtasks, coding, and testing activities are followed, compared to TDD. The results also indicate that the participants produce higher quality code during the implementation of Bowling Score Keeper, compared to that of Mars Rover API, although they perceived both tasks as of similar complexity. An interaction between the development approach and task could not be observed in this experiment. We conclude that variables that have not been explored so often, such as the extent to which the task is specified in terms of smaller subtasks, and developers' unit testing experience might be critical factors in TDD experiments. The real-world appliance of TDD and its implications on external quality still remain to be challenging unless these uncontrolled and unconsidered factors are further investigated by researchers in both academic and industrial settings.","1939-3520","","10.1109/TSE.2019.2949811","Ministerio de Ciencia e Innovación(grant numbers:PGC2018-097265-B-I00); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8884172","Test-driven development;industry experiment;experimental task;incremental test-last development;external quality","Task analysis;Industries;Bibliographies;Productivity;Programming profession;Organizations","","","","1","","","IEEE","28 Oct 2019","","","IEEE","IEEE Early Access Articles"
"Effects of Developer Experience on Learning and Applying Unit Test-Driven Development","R. Latorre","Universidad Autónoma de Madrid, Madrid, Spain","IEEE Transactions on Software Engineering","2 May 2014","2014","40","4","381","395","Unit test-driven development (UTDD) is a software development practice where unit test cases are specified iteratively and incrementally before production code. In the last years, researchers have conducted several studies within academia and industry on the effectiveness of this software development practice. They have investigated its utility as compared to other development techniques, focusing mainly on code quality and productivity. This quasi-experiment analyzes the influence of the developers' experience level on the ability to learn and apply UTDD. The ability to apply UTDD is measured in terms of process conformance and development time. From the research point of view, our goal is to evaluate how difficult is learning UTDD by professionals without any prior experience in this technique. From the industrial point of view, the goal is to evaluate the possibility of using this software development practice as an effective solution to take into account in real projects. Our results suggest that skilled developers are able to quickly learn the UTDD concepts and, after practicing them for a short while, become as effective in performing small programming tasks as compared to more traditional test-last development techniques. Junior programmers differ only in their ability to discover the best design, and this translates into a performance penalty since they need to revise their design choices more frequently than senior programmers.","1939-3520","","10.1109/TSE.2013.2295827","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6690135","Test-driven development;test-first design;software engineering process;software quality/SQA;software construction;process conformance;programmer productivity","Software;Testing;Training;Programming profession;Context;Production","learning (artificial intelligence);program testing;software quality","learning;unit test-driven development;UTDD;software development;code quality;productivity","","13","","44","IEEE","20 Dec 2013","","","IEEE","IEEE Journals"
"Moving from Closed to Open Source: Observations from Six Transitioned Projects to GitHub","P. S. Kochhar; E. Kalliamvakou; N. Nagappan; T. Zimmermann; C. Bird","Microsoft, Vancouver, BC, Canada; University of Victoria, Victoria, BC, Canada; Microsoft Research, Redmond, WA, USA; Microsoft Research, Redmond, WA, USA; Microsoft Research, Redmond, WA, USA","IEEE Transactions on Software Engineering","16 Sep 2021","2021","47","9","1838","1856","Open source software systems have gained a lot of attention in the past few years. With the emergence of open source platforms like GitHub, developers can contribute, store, and manage their projects with ease. Large organizations like Microsoft, Google, and Facebook are open sourcing their in-house technologies in an effort to more broadly involve the community in the development of software systems. Although closed source and open source systems have been studied extensively, there has been little research on the transition from closed source to open source systems. Through this study we aim to: a) provide guidance and insights for other teams planning to open source their projects and b) to help them avoid pitfalls during the transition process. We studied six different Microsoft systems, which were recently open-sourced i.e., CoreFX, CoreCLR, Roslyn, Entity Framework, MVC, and Orleans. This paper presents the transition from the viewpoints of both Microsoft and the open source community based on interviews with eleven Microsoft developer, five Microsoft senior managers involved in the decision to open source, and eleven open-source developers. From Microsoft’s perspective we discuss the reasons for the transition, experiences of developers involved, and the transition’s outcomes and challenges. Our results show that building a vibrant community, prompt answers, developing an open source culture, security regulations and business opportunities are the factors which persuade companies to open source their products. We also discuss the transition outcomes on processes such as code reviews, version control systems, continuous integration as well as developers’ perception of these changes. From the open source community’s perspective, we illustrate the response to the open-sourcing initiative through contributions and interactions with the internal developers and provide guidelines for other projects planning to go open source.","1939-3520","","10.1109/TSE.2019.2937025","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812899","Empirical study;GitHub;open-source;Microsoft","Interviews;Encoding;Planning;Software systems;Open source software;Companies","","","","1","","51","IEEE","26 Aug 2019","","","IEEE","IEEE Journals"
"Corrections to ""the effectiveness of control structure diagrams in source code comprehension activities""","D. Hendrix; J. H. Cross; S. Maghsoodloo",Auburn University; NA; NA,"IEEE Transactions on Software Engineering","7 Aug 2002","2002","28","6","624","624","","1939-3520","","10.1109/TSE.2002.1010064","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1010064","","Java;Senior members;Back;Visualization;Computer science;Software engineering;Systems engineering and theory","","","","","","1","","7 Aug 2002","","","IEEE","IEEE Journals"
"The Eden System: A Technical Review","G. T. Almes; A. P. Black; E. D. Lazowska; J. D. Noe","Department of Computer Science, University of Washington; NA; NA; NA","IEEE Transactions on Software Engineering","18 Sep 2006","1985","SE-11","1","43","59","The Eden project is a five year experiment in designing, building, and using an ""integrated distributed"" computing system. We are attempting to combine the benefits of integration and distribution by supporting an object based style of programming on top of a node machine/local network hardware base. Our experimental hypothesis is that such an architecture will provide an environment conducive to building distributed applications.","1939-3520","","10.1109/TSE.1985.231536","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1701897","Capability;Concurrent Euclid;concurrent programming;distributed electronic mail;distributed program;distributed system;Eden;object-oriented system;remote procedure call","Distributed computing;Buildings;Kernel;Computer languages;Libraries;Computer architecture;History;Costs;Concurrent computing;Senior members","","Capability;Concurrent Euclid;concurrent programming;distributed electronic mail;distributed program;distributed system;Eden;object-oriented system;remote procedure call","","161","18","18","","18 Sep 2006","","","IEEE","IEEE Journals"
